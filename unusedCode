
-(void)setLocationOfSpriteNamed:(NSString *)name mean:(CGFloat)mean min:(CGFloat)min max:(CGFloat)max sdev:(CGFloat)sdev minGrey:(CGFloat)minGrey ratio:(CGFloat)ratio{

CGFloat median = (max-min)/2.0;
CGFloat adjmean = (mean-minGrey)*ratio+kSceneMargin;
CGFloat adjmin = (min-minGrey)*ratio+kSceneMargin;
CGFloat adjmax = (max-minGrey)*ratio+kSceneMargin;
CGFloat adjsdev = sdev*ratio;
CGFloat adjrange = (adjmax-adjmin);
CGFloat adjmedian = (adjmax-adjmin)/2.0;
SKSpriteNode *rangenode = (SKSpriteNode *)[self.skScene childNodeWithName:[name stringByAppendingString:@"R"]];
if (rangenode != nil) {
rangenode.position = CGPointMake(adjmin+adjmedian, rangenode.position.y);
rangenode.size = CGSizeMake(adjrange, rangenode.size.height);
}
SKSpriteNode *sdnode = (SKSpriteNode *)[self.skScene childNodeWithName:[name stringByAppendingString:@"S"]];
if (sdnode != nil) {
sdnode.position = CGPointMake(adjmean, rangenode.position.y);
sdnode.size = CGSizeMake(adjsdev*2.0, sdnode.size.height);
[self colourNode:sdnode forName:name];
//mean node moves with SD node
}

//update text
[(SKLabelNode *)[self.skScene childNodeWithName:[name stringByAppendingString:@"T"]] setText:[NSString stringWithFormat:@"%.0f ± %.0f (%.0f—%.0f—%.0f)", mean, sdev, min, median, max]];

}




+(unsigned char*)ClonedBufferFromROI:(ROI *)roi2Clone
{
int textureBuffer_Length = roi2Clone.textureHeight * roi2Clone.textureWidth;
int textureBuffer_Width = roi2Clone.textureWidth;

unsigned char   *tempBuffer = (unsigned char*)malloc(textureBuffer_Length*sizeof(unsigned char));

for (int pixelIndex = 0; pixelIndex<textureBuffer_Length; pixelIndex+=textureBuffer_Width) {
//copy the row mask
for (int col=0; col<textureBuffer_Width; col++) {
tempBuffer[pixelIndex+col] = roi2Clone.textureBuffer[pixelIndex+col];
}
}
return tempBuffer;
}





+(NSPoint)deltaXYFromROI:(ROI*)roi2Clone ipsiROI:(ROI*)ipsiROI contraROI:(ROI*)contraROI
{
NSPoint deltaPoint = NSMakePoint(CGFLOAT_MAX, CGFLOAT_MAX);

if (roi2Clone && ipsiROI && contraROI) {
deltaPoint.x =
([contraROI centroid].x - [ipsiROI centroid].x) + roi2Clone.textureWidth;
//+ (1.0*([ipsiROI centroid].x - [roi2Clone centroid].x));
deltaPoint.y =
[contraROI centroid].y - [ipsiROI centroid].y +
(1.0*([ipsiROI centroid].y - [roi2Clone centroid].y));
//2* becaumse we mirror around the contra anchor

}
return deltaPoint;
}


+(ROI*) roiFromList:(NSMutableArray *)roiList WithName:(NSString*)name2Find
{
for (ROI *roi in roiList) {
if ([roi.name isEqualToString:name2Find]){return roi;}
}
return nil;
}


- (IBAction)unassignCTwindowClicked:(id)sender {
[self assignViewerWindow:nil forType:CT_Window];
}
- (IBAction)unassignPETwindowClicked:(id)sender {
[self assignViewerWindow:nil forType:PET_Window];
}

-(IBAction)quickPasteCTPET:(NSButton *)sender {
if (sender.tag >= 0)//PET2CT
{
switch (sender.tag) {
case Mirrored_ROI:
case Active_ROI:
[self doPasteBrushROIsAsPolygonsFromPET2CT:sender.tag];
break;
case MirroredAndActive_ROI:
[self doPasteBrushROIsAsPolygonsFromPET2CT:Mirrored_ROI];
[self doPasteBrushROIsAsPolygonsFromPET2CT:Active_ROI];
break;
case Transform_ROI_Placed:
[self copyROIsFromViewerController:self.viewerPET ofType:tMesure withOptionalName:self.textLengthROIname.stringValue ofROIMirrorType:Transform_ROI_Placed];
[self pasteROIsForViewerController:self.viewerCT ofType:tMesure withOptionalName:self.textLengthROIname.stringValue ofROIMirrorType:Transform_ROI_Placed];
break;
default:
break;
}
}
else //CT2PET
{
switch (labs(sender.tag)) {
case Mirrored_ROI:
case Active_ROI:
[self doPasteBrushROIsAsPolygonsFromCT2PET:sender.tag];
break;
case MirroredAndActive_ROI:
[self doPasteBrushROIsAsPolygonsFromCT2PET:Mirrored_ROI];
[self doPasteBrushROIsAsPolygonsFromCT2PET:Active_ROI];
break;
case Transform_ROI_Placed:
[self copyROIsFromViewerController:self.viewerCT ofType:tMesure withOptionalName:self.textLengthROIname.stringValue ofROIMirrorType:Transform_ROI_Placed];
[self pasteROIsForViewerController:self.viewerPET ofType:tMesure withOptionalName:self.textLengthROIname.stringValue ofROIMirrorType:Transform_ROI_Placed];
break;
default:
break;
}
}
}

-(void)burnActiveAndMirrorROIsIntoCTViewer {
//create a dummy roi just for the name
[self.viewerPET revertSeries:nil];

ROI *aROI = [self.viewerPET newROI:tPlain];
aROI.name = self.textMirrorROIname.stringValue;
//roiSetPixels:(ROI*)aROI :(short)allRois :(BOOL)propagateIn4D :(BOOL)outside :(float)minValue :(float)maxValue :(float)newValue;
[self.viewerPET roiSetPixels: aROI :SetPixels_SameName :NO :NO :-FLT_MAX :FLT_MAX :FLT_MAX :YES];
aROI.name = self.textActiveROIname.stringValue;
[self.viewerPET roiSetPixels: aROI :SetPixels_SameName :NO :NO :-FLT_MAX :FLT_MAX :FLT_MAX :YES];
[self.viewerPET needsDisplayUpdate];
[self.viewerCT needsDisplayUpdate];

}


-(IBAction)buttonAction:(NSButton *)sender {
//Transform Front
if ([sender.identifier isEqualToString:@"pasteTransformFront"]) {
[self pasteROIsForViewerController:[ViewerController frontMostDisplayed2DViewer] ofType:tMesure withOptionalName:self.textLengthROIname.stringValue ofROIMirrorType:Transform_ROI_Placed];
}
else  if ([sender.identifier isEqualToString:@"copyTransformFront"]) {
[self copyROIsFromViewerController:[ViewerController frontMostDisplayed2DViewer] ofType:tMesure withOptionalName:self.textLengthROIname.stringValue ofROIMirrorType:Transform_ROI_Placed];
}
else  if ([sender.identifier isEqualToString:@"deleteTransformFront"]) {
[self deleteROIsFromViewerController:[ViewerController frontMostDisplayed2DViewer] ofType:tMesure withOptionalName:self.textLengthROIname.stringValue];
}
else  if ([sender.identifier isEqualToString:@"hideTransformFront"]) {
[self doShowHideTransformMarkersForViewerController:[ViewerController frontMostDisplayed2DViewer]];
}
// Transform CT window
else  if ([sender.identifier isEqualToString:@"deleteTransformCT"]) {
[self deleteROIsFromViewerController:self.viewerCT ofType:tMesure withOptionalName:self.textLengthROIname.stringValue];
}
else  if ([sender.identifier isEqualToString:@"hideTransformCT"]) {
[self doShowHideTransformMarkersForViewerController:self.viewerCT];
}
}

- (IBAction)deleteActiveViewerPolygonROIsOfType:(NSButton *)sender {
switch (sender.tag) {
case Mirrored_ROI:
[self deleteROIsFromViewerController:[ViewerController frontMostDisplayed2DViewer] ofType:tCPolygon withOptionalName:self.textMirrorROIname.stringValue];
break;
case Active_ROI:
[self deleteROIsFromViewerController:[ViewerController frontMostDisplayed2DViewer] ofType:tCPolygon withOptionalName:self.textActiveROIname.stringValue];
break;

default:
break;
}
}
- (IBAction)pasteActiveViewerROIsOfType:(NSButton *)sender {
switch (sender.tag) {
case Mirrored_ROI:
[self pasteROIsForViewerController:[ViewerController frontMostDisplayed2DViewer] ofType:tPlain withOptionalName:self.textMirrorROIname.stringValue ofROIMirrorType:Mirrored_ROI];
break;
case Active_ROI:
[self pasteROIsForViewerController:[ViewerController frontMostDisplayed2DViewer] ofType:tPlain withOptionalName:self.textActiveROIname.stringValue ofROIMirrorType:Active_ROI];
break;

default:
break;
}
}
- (IBAction)copyActiveViewerROIsOfType:(NSButton *)sender {
switch (sender.tag) {
case Mirrored_ROI:
[self copyROIsFromViewerController:[ViewerController frontMostDisplayed2DViewer] ofType:tPlain withOptionalName:self.textMirrorROIname.stringValue ofROIMirrorType:Mirrored_ROI];
break;
case Active_ROI:
[self copyROIsFromViewerController:[ViewerController frontMostDisplayed2DViewer] ofType:tPlain withOptionalName:self.textActiveROIname.stringValue ofROIMirrorType:Active_ROI];
break;

default:
break;
}
}




- (void)copyROIsFromViewerController:(ViewerController *)active2Dwindow ofType:(int)type withOptionalName:(NSString *)name ofROIMirrorType:(ROI_Type)roiMirrorType
{
NSMutableArray *scratchArray = [self arrayOfROIsFromViewerController:active2Dwindow ofType:type withOptionalName:name ofROIMirrorType:roiMirrorType];

switch (roiMirrorType) {
case Mirrored_ROI:
self.arrayMirrorROIsCopied  = [NSMutableArray arrayWithArray:scratchArray];
break;
case Transform_ROI_Placed:
self.arrayTransformROIsCopied  = [NSMutableArray arrayWithArray:scratchArray];
break;
case Active_ROI:
self.arrayActiveROIsCopied  = [NSMutableArray arrayWithArray:scratchArray];
break;
default:
break;
}

if(scratchArray.count == 0)
{
NSRunCriticalAlertPanel(NSLocalizedString(@"ROIs Save Error",nil), NSLocalizedString(@"No ROIs in this series!",nil) , NSLocalizedString(@"OK",nil), nil, nil);
}
}

-(NSMutableArray *)arrayOfROIsFromViewerController:(ViewerController *)active2Dwindow ofType:(int)type withOptionalName:(NSString *)name ofROIMirrorType:(ROI_Type)roiMirrorType
{
NSMutableArray *scratchArray = [NSMutableArray  arrayWithCapacity:[[active2Dwindow pixList] count]];

for (NSUInteger pixIndex = 0; pixIndex < [[active2Dwindow pixList] count]; pixIndex++)
{
NSMutableArray  *roisPerImages = [NSMutableArray  array];
NSMutableArray *roiListInVC = [active2Dwindow roiList];
for( int roiIndex = 0; roiIndex < [[roiListInVC objectAtIndex: pixIndex] count]; roiIndex++)
{
ROI	*curROI = [[[roiListInVC objectAtIndex: pixIndex] objectAtIndex: roiIndex] copy];
if ((curROI.type == type) && (name == nil || name == curROI.name))
{
[roisPerImages addObject: curROI];
}
}

[scratchArray addObject: roisPerImages];
}
return scratchArray;
}


-(void)doPasteBrushROIsAsPolygonsFromCT2PET:(ROI_Type)roiMirrorType {
NSString *ROIname = nil;
switch (roiMirrorType) {
case Mirrored_ROI:
ROIname = self.textMirrorROIname.stringValue;
break;
case Active_ROI:
ROIname = self.textActiveROIname.stringValue;
break;
default:
break;
}
NSMutableArray *scratchArray = [self arrayOfROIsFromViewerController:self.viewerCT ofType:tCPolygon withOptionalName:ROIname ofROIMirrorType:roiMirrorType];
if (scratchArray.count > 0) {
[self pasteROIsFromArray:scratchArray ofType:tCPolygon withOptionalName:ROIname ofROIMirrorType:roiMirrorType intoViewerController:self.viewerPET];
}
}

-(void)doPasteBrushROIsAsPolygonsFromPET2CT:(ROI_Type)roiMirrorType {
NSString *ROIname = nil;
switch (roiMirrorType) {
case Mirrored_ROI:
ROIname = self.textMirrorROIname.stringValue;
break;
case Active_ROI:
ROIname = self.textActiveROIname.stringValue;
break;
default:
break;
}
NSMutableArray *scratchArray = [self arrayOfROIsFromViewerController:self.viewerPET ofType:tPlain withOptionalName:ROIname ofROIMirrorType:roiMirrorType];
if (scratchArray.count > 0) {
for(NSUInteger pixIndex = 0; pixIndex < [scratchArray count]; pixIndex++)
{
NSMutableArray *roisImages = [scratchArray objectAtIndex: pixIndex];
for(NSUInteger imIndex = 0; imIndex<roisImages.count; imIndex++)
{
ROI *poly = [self.viewerPET convertBrushROItoPolygon:[roisImages objectAtIndex:imIndex] numPoints:200];
poly.name = ROIname;
[roisImages replaceObjectAtIndex:imIndex withObject:poly];

}
}
[self pasteROIsFromArray:scratchArray ofType:tCPolygon withOptionalName:ROIname ofROIMirrorType:roiMirrorType intoViewerController:self.viewerCT];
}

}

- (void)pasteROIsForViewerController:(ViewerController *)active2Dwindow ofType:(int)type withOptionalName:(NSString *)name ofROIMirrorType:(ROI_Type)roiMirrorType
{
switch (roiMirrorType) {
case Mirrored_ROI:
[self pasteROIsFromArray:[NSMutableArray arrayWithArray:self.arrayMirrorROIsCopied] ofType:type withOptionalName:name ofROIMirrorType:roiMirrorType intoViewerController:active2Dwindow];
break;
case Transform_ROI_Placed:
[self pasteROIsFromArray:[NSMutableArray arrayWithArray:self.arrayTransformROIsCopied] ofType:type withOptionalName:name ofROIMirrorType:roiMirrorType intoViewerController:active2Dwindow];
break;
case Active_ROI:
[self pasteROIsFromArray:[NSMutableArray arrayWithArray:self.arrayActiveROIsCopied] ofType:type withOptionalName:name ofROIMirrorType:roiMirrorType intoViewerController:active2Dwindow];
break;
default:
break;
}
}

-(void)pasteROIsFromArray:(NSMutableArray *)scratchArray ofType:(int)type withOptionalName:(NSString *)name ofROIMirrorType:(ROI_Type)roiMirrorType intoViewerController:(ViewerController *)active2Dwindow
{
NSMutableArray *pixListInActiveVC = [active2Dwindow pixList];
for(NSUInteger pixIndex = 0; pixIndex < [pixListInActiveVC count]; pixIndex++)
{
DCMPix *curDCM = [pixListInActiveVC objectAtIndex: pixIndex];

if( [scratchArray count] > pixIndex)
{
NSArray *roisImages = [scratchArray objectAtIndex: pixIndex];
for( ROI *unpackedROI in roisImages)
{
if ((unpackedROI.type == type) && (name == nil || name == unpackedROI.name))
{
//Correct the origin only if the orientation is the same
unpackedROI.pix = curDCM;
[unpackedROI setOriginAndSpacing: curDCM.pixelSpacingX :curDCM.pixelSpacingY :[DCMPix originCorrectedAccordingToOrientation: curDCM]];
[[active2Dwindow.roiList objectAtIndex: pixIndex] addObject: unpackedROI];
unpackedROI.curView = active2Dwindow.imageView;
[unpackedROI recompute];
}
}
}
}
[active2Dwindow.imageView setIndex: active2Dwindow.imageView.curImage];
[active2Dwindow needsDisplayUpdate];

}

-(void)pasteAllROIsFromArray:(NSMutableArray *)scratchArray intoViewerController:(ViewerController *)active2Dwindow hidden:(BOOL)hidden
{
NSMutableArray *pixListInActiveVC = [active2Dwindow pixList];
for(NSUInteger pixIndex = 0; pixIndex < [pixListInActiveVC count]; pixIndex++)
{
DCMPix *curDCM = [pixListInActiveVC objectAtIndex: pixIndex];

if( [scratchArray count] > pixIndex)
{
NSArray *roisImages = [scratchArray objectAtIndex: pixIndex];
for( ROI *unpackedROI in roisImages)
{
//Correct the origin only if the orientation is the same
unpackedROI.pix = curDCM;
unpackedROI.hidden = hidden;
[unpackedROI setOriginAndSpacing: curDCM.pixelSpacingX :curDCM.pixelSpacingY :[DCMPix originCorrectedAccordingToOrientation: curDCM]];
[[active2Dwindow.roiList objectAtIndex: pixIndex] addObject: unpackedROI];
unpackedROI.curView = active2Dwindow.imageView;
[unpackedROI recompute];
}
}
}
[active2Dwindow.imageView setIndex: active2Dwindow.imageView.curImage];
[active2Dwindow needsDisplayUpdate];

}

+(NSMutableArray *)allROIinFrontDCMPixFromViewerController:(ViewerController *)theVC
{
NSMutableArray  *roisInAllSlices  = [theVC roiList];
int indexOfFrontDCMPix =  [[theVC imageView] curImage];
if (roisInAllSlices.count>indexOfFrontDCMPix) {
return [roisInAllSlices objectAtIndex: indexOfFrontDCMPix];
}
return nil;
}

+(ROI*) roiFromList:(NSMutableArray *)roiList WithName:(NSString*)name2Find
{
for (ROI *roi in roiList) {
if ([roi.name isEqualToString:name2Find]){return roi;}
}
return nil;
}

- (void)deleteROIsFromViewerController:(ViewerController *)active2Dwindow ofType:(int)type withOptionalName:(NSString *)name
{
for (NSUInteger pixIndex = 0; pixIndex < [[active2Dwindow pixList] count]; pixIndex++)
{
for( int roiIndex = 0; roiIndex < [[[active2Dwindow roiList] objectAtIndex: pixIndex] count]; roiIndex++)
{
ROI	*curROI = [[[active2Dwindow roiList] objectAtIndex: pixIndex] objectAtIndex: roiIndex];
if ((type == tAnyROItype || curROI.type == type) && (name == nil || name == curROI.name))
{
[[[active2Dwindow roiList] objectAtIndex: pixIndex] removeObjectAtIndex:roiIndex];
}
}
}
[active2Dwindow needsDisplayUpdate];
}

-(void)doShowHideTransformMarkersForViewerController:(ViewerController *)active2Dwindow
{
//ViewerController	*active2Dwindow = [ViewerController frontMostDisplayed2DViewer];
NSMutableArray  *roisInAllSlices  = [active2Dwindow roiList];
for (NSUInteger slice=0; slice<roisInAllSlices.count; slice++) {
NSMutableArray *roisInThisSlice = [roisInAllSlices objectAtIndex:slice];
ROI *ROI2showHide = [MirrorROIPluginFilterOC roiFromList:roisInThisSlice WithType:tMesure];
if (ROI2showHide != nil) {
ROI2showHide.hidden = !ROI2showHide.hidden;
}
}
}

+ (NSInteger)indexOfFirstROIInFromViewerController:(ViewerController *)active2Dwindow atSlice:(NSUInteger)slice withName:(NSString *)name {
if (slice<active2Dwindow.roiList.count) {
for (NSInteger i=0; i<[[active2Dwindow.roiList objectAtIndex:slice] count];i++) {
ROI *roi = [[active2Dwindow.roiList objectAtIndex:slice] objectAtIndex:i];
if ([roi.name isEqualToString:name]) {
return i;
}
}
}
return NSNotFound;
}
